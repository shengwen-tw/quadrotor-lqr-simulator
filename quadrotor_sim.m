function quadrotor_sim
	ITERATION_TIMES = 10000;

	math = se3_math;

	uav_dynamics = dynamics;        %create uav dynamics object
	uav_dynamics.dt = 0.001;        %set iteration period [sec]
	uav_dynamics.mass = 1;          %set uav mass [kg]
	uav_dynamics.a = [0; 0; 0];     %acceleration of uav [m/s^2], effected by applied force
	uav_dynamics.v = [0; 0; 9.8];     %initial velocity of uav [m/s]
	uav_dynamics.x = [3; 0; -7];    %initial position of uav [m]
	uav_dynamics.W = [0; 0; 0];     %initial angular velocity of uav
	uav_dynamics.W_dot = [0; 0; 0]; %angular acceleration of uav, effected by applied moment
	uav_dynamics.f = [0; 0; 0];     %force generated by controller
	uav_dynamics.M = [0; 0; 0];     %moment generated by controller
    
	%set initial attitude (DCM)
	init_attitude(1) = deg2rad(30); %roll
	init_attitude(2) = deg2rad(30); %pitch
	init_attitude(3) = deg2rad(0);  %yaw
	uav_dynamics.R = math.euler_to_dcm(init_attitude(1), init_attitude(2), init_attitude(3));

	uav_dynamics.J = [0.01466 0 0;  %inertia matrix of uav
			  0 0.01466 0;
			  0 0 0.02848];

    c = -9.8; %quadrotor thrust
          
	quad_sim_greeting(uav_dynamics, ITERATION_TIMES, init_attitude);

	%lqr parameters
    Q = zeros(10, 10);
    Q(1, 1) = 100;   %px
    Q(2, 2) = 100;   %py
    Q(3, 3) = 100;   %pz
    Q(4, 4) = 1;     %q0
    Q(5, 5) = 1;     %q1
    Q(6, 6) = 1;     %q2
    Q(7, 7) = 10;    %q3
    Q(8, 8) = 10;    %vx
    Q(9, 9) = 10;    %vy
    Q(10, 10) = 10;  %vz
    
    R = zeros(4, 4);
    R(1, 1) = 1; %wx
    R(2, 2) = 5; %wy
    R(3, 3) = 5; %wz
    R(4, 4) = 0.1; %c
    
    %bodyrate controller
    kW = [2; 2; 2];
    
	%controller setpoints	
	xd = zeros(3, ITERATION_TIMES);
	vd = zeros(3, ITERATION_TIMES);
	a_d = [0; 0; 0];
	yaw_d = zeros(1, ITERATION_TIMES);
	Wd = [0; 0; 0];
	W_dot_d = [0; 0; 0];

	%%%%%%%%%%%%%%%%%%%%%
	%   path planning   %
	%%%%%%%%%%%%%%%%%%%%%
	% cirular motion
	radius = 3;        %[m]
	circum_rate = 0.25; %[hz], times of finished a circular trajectory per second
	yaw_rate = 0.05;    %[hz], times of full rotation around z axis per second
	for i = 1: ITERATION_TIMES
		%plan heading
		if i == 1
			yaw_d(1) = 0;
		else
			yaw_d(i) = yaw_d(i - 1) + (yaw_rate * uav_dynamics.dt * 2 * pi);
		end
		if yaw_d(i) > pi %bound yaw angle between +-180 degree
			yaw_d(i) = yaw_d(i) - (2 * pi);
		end

		%plan position
		xd(1, i) = radius * cos(circum_rate * uav_dynamics.dt * i * pi);
		xd(2, i) = radius * sin(circum_rate * uav_dynamics.dt * i * pi);
		xd(3, i) = -1;

		%plan velocity
		vd(1, i) = radius * -sin(circum_rate * uav_dynamics.dt * i * pi);
		vd(2, i) = radius * cos(circum_rate * uav_dynamics.dt * i * pi);
		vd(3, i) = 0;
	end

	%plot datas
	time_arr = zeros(1, ITERATION_TIMES);
	accel_arr = zeros(3, ITERATION_TIMES);
	vel_arr.g = zeros(3, ITERATION_TIMES);
	R_arr = zeros(3, 3, ITERATION_TIMES);
	euler_arr = zeros(3, ITERATION_TIMES);
	pos_arr = zeros(3, ITERATION_TIMES);
	W_dot_arr = zeros(3, ITERATION_TIMES);
	W_arr = zeros(3, ITERATION_TIMES);
	M_arr = zeros(3, ITERATION_TIMES);
	prv_angle_arr = zeros(1, ITERATION_TIMES);
	eR_prv_arr = zeros(3, ITERATION_TIMES);
	eR_arr = zeros(3, ITERATION_TIMES);
	eW_arr = zeros(3, ITERATION_TIMES);
	ex_arr = zeros(3, ITERATION_TIMES);
	ev_arr = zeros(3, ITERATION_TIMES);

	for i = 1: ITERATION_TIMES
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Update System Dynamics %
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		uav_dynamics = update(uav_dynamics);
        q = math.dcm_to_quaternion(uav_dynamics.R); %DCM to quaternion
        
		%%%%%%%%%%%%%%%%%%%%%%%%%
		% Quadrotor LQR Control %
		%%%%%%%%%%%%%%%%%%%%%%%%%
        
		%construct system state vecoctor
        x = [uav_dynamics.x; q; uav_dynamics.v];

        %construct A matrix
        dpdot_dv = eye(3);
        
        q_norm = norm(q);
        v = (eye(4) - (q_norm^-2)*q* transpose(q)) / q_norm;
        
        wx = uav_dynamics.W(1);
        wy = uav_dynamics.W(2);
        wz = uav_dynamics.W(3);
        W = [0  -wx -wy -wz;
             wx  0   wz -wy;
             wy -wz   0  wx;
             wz  wy -wx  0];
        dqdot_dq = 0.5 * W * v;
        
        qw = q(1);
        qx = q(2);
        qy = q(3);
        qz = q(4);
        
        q_matrix = [ qy  qz  qw qx;
                    -qx -qw  qz qy;
                     qw -qx -qy qz];
        dvdot_dq = 2 * c * q_matrix * v;
        
        A = [zeros(3, 3) zeros(3 ,4) dpdot_dv;
             zeros(4, 3) dqdot_dq    zeros(4, 3);
             zeros(3, 3) dvdot_dq    zeros(3, 3)];
        
        %construct B matrix
        dqdot_dw = 0.5 * [-qx -qy -qz;
                           qw -qz  qy;
                           qz  qw -qx;
                          -qy  qx  qw];
        
        dvdot_dc = [2*(qw*qy + qx*qz);
                    2*(qy*qz - qw*qx);
                    qw^2 - qx^2 - qy^2 + qz^2];
        
        B = [zeros(3, 3)  zeros(3, 1);
                dqdot_dw  zeros(4, 1);
             zeros(3, 3)    dvdot_dc];

        %check controllability
        if true
            A
            B
            size(A);
            size(B);
            size(ctrb(A, B));
            disp('uncontrollable state counts:')
            length(A) - rank(ctrb(A, B))
        end
         
        %construct desired state vector
        p_d = [0; 0; 0];    %desired position
        q_d = [1; 0; 0; 0]; %desired attitude quaternion
        v_d = [0; 0; 0];    %desired velocity
        x_d = [p_d; q_d; v_d];        
        
        %solve CARE
        [X, L, G] = care(A, B, Q, R);
        %K = inv(R) * transpose(B) * X;
        
        %calculate lqr control output
        u = -K*(x - x_d);
        uav_ctrl_f = c * uav_dynamics.R * [0; 0; 1];
        w_des = [u(1); u(2); u(3)];
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Quadrotor Bodyrate Control %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %w_des = [deg2rad(50); deg2rad(50); deg2rad(50)];
        eW = [uav_dynamics.W(1) - w_des(1);
              uav_dynamics.W(2) - w_des(2);
              uav_dynamics.W(3) - w_des(3)];
              
        uav_ctrl_M = [-kW(1) * eW(1);
                      -kW(2) * eW(2);
                      -kW(3) * eW(3)];

		%feed
		uav_dynamics.M = uav_ctrl_M;
		uav_dynamics.f = uav_ctrl_f;
        
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Record datas for plotting %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		time_arr(i) = i * uav_dynamics.dt;
		time_arr(i) = i * uav_dynamics.dt;
		eR_prv_arr(:, i) = 0; %rad2deg(eR_prv);
		eR_arr(:, i) = 0; %rad2deg(eR);
		eW_arr(:, i) = 0; %rad2deg(eW);
		accel_arr(:, i) = uav_dynamics.a;
		vel_arr.g(:, i) = uav_dynamics.v;
		pos_arr(:, i) = uav_dynamics.x;
		R_arr(:, :, i) = uav_dynamics.R;
		euler_arr(:, i) = 0; %rad2deg(math.dcm_to_euler(uav_dynamics.R));
		W_dot_arr(:, i) = rad2deg(uav_dynamics.W_dot);
		W_arr(:, i) = rad2deg(uav_dynamics.W);
		M_arr(:, i) = uav_dynamics.M;
		ex_arr(:, i) = 0; %ex;
		ev_arr(:, i) = 0; %ev;
	end

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Animate the simulation result %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%rigidbody_visualize([7; 7; 7], pos_arr, R_arr, ITERATION_TIMES, uav_dynamics.dt, 30);

	%%%%%%%%%%%%%%%%%%%%%%%%%%
	%          Plot          %
	%%%%%%%%%%%%%%%%%%%%%%%%%%

	%attitude (euler angles)
	figure('Name', 'attitude (euler angles)');
	subplot (3, 1, 1);
	plot(time_arr, W_arr(1, :));
	title('attitude (euler angles)');
	xlabel('time [s]');
	ylabel('roll [deg]');
	subplot (3, 1, 2);
	plot(time_arr, W_arr(2, :));
	xlabel('time [s]');
	ylabel('pitch [deg]');
	subplot (3, 1, 3);
	plot(time_arr, W_arr(3, :));
	xlabel('time [s]');
	ylabel('yaw [deg]');

	disp("Press any key to leave");
	pause;
end

function quad_sim_greeting(dynamics, iteration_times, init_attitude)
	roll = rad2deg(init_attitude(1));
	pitch = rad2deg(init_attitude(2));
	yaw = rad2deg(init_attitude(3));
	disp(sprintf('Quadrotor simulation (%d iterations, dt = %dsec)', iteration_times, dynamics.dt));
	disp(sprintf('Initial position: (%f, %f, %f)', dynamics.x(1), dynamics.x(2), dynamics.x(3)));
	disp(sprintf('Initial attitude (euler angle): (%f, %f, %f)', roll, pitch, yaw));
	disp('Start simulation...');
end
