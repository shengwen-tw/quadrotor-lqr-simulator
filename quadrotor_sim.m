function quadrotor_sim
	ITERATION_TIMES = 10000;

	math = se3_math;

	uav_dynamics = dynamics;        %create uav dynamics object
	uav_dynamics.dt = 0.001;        %set iteration period [sec]
	uav_dynamics.mass = 1;          %set uav mass [kg]
	uav_dynamics.a = [0; 0; 0];     %acceleration of uav [m/s^2], effected by applied force
	uav_dynamics.v = [0; 0; 0];     %initial velocity of uav [m/s]
	uav_dynamics.x = [3; 0; -7];    %initial position of uav [m]
	uav_dynamics.W = [0; 0; 0];     %initial angular velocity of uav
	uav_dynamics.W_dot = [0; 0; 0]; %angular acceleration of uav, effected by applied moment
	uav_dynamics.f = [0; 0; 0];     %force generated by controller
	uav_dynamics.M = [0; 0; 0];     %moment generated by controller

	%set initial attitude (DCM)
	init_attitude(1) = deg2rad(180); %roll
	init_attitude(2) = deg2rad(0);   %pitch
	init_attitude(3) = deg2rad(0);   %yaw
	uav_dynamics.R = math.euler_to_dcm(init_attitude(1), init_attitude(2), init_attitude(3));

	uav_dynamics.J = [0.01466 0 0;  %inertia matrix of uav
			  0 0.01466 0;
			  0 0 0.02848];

	quad_sim_greeting(uav_dynamics, ITERATION_TIMES, init_attitude);

	%lqr parameters
    Q = zeros(10, 10);
    Q(1, 1) = 1;   %px
    Q(2, 2) = 1;   %py
    Q(3, 3) = 1;   %pz
    Q(4, 4) = 1;   %q0
    Q(5, 5) = 1;   %q1
    Q(6, 6) = 1;   %q2
    Q(7, 7) = 1;   %q3
    Q(8, 8) = 1;   %vx
    Q(9, 9) = 1;   %vy
    Q(10, 10) = 1; %vz
    
    R = zeros(4, 4);
    R(1, 1) = 1; %wx
    R(2, 2) = 1; %wy
    R(3, 3) = 1; %wz
    R(4, 4) = 1; %c

    %full state feedback control gain
    K_full_state_fb = zeros(10);
    K_full_state_fb(1) = 1;   %px
    K_full_state_fb(2) = 1;   %py
    K_full_state_fb(3) = 1;   %pz
    K_full_state_fb(4) = 1;   %q0
    K_full_state_fb(5) = 1;   %q1
    K_full_state_fb(6) = 1;   %q2
    K_full_state_fb(7) = 1;   %q3
    K_full_state_fb(8) = 1;   %vx
    K_full_state_fb(9) = 1;   %vy
    K_full_state_fb(10) = 1;  %vz
    
	%controller setpoints	
	xd = zeros(3, ITERATION_TIMES);
	vd = zeros(3, ITERATION_TIMES);
	a_d = [0; 0; 0];
	yaw_d = zeros(1, ITERATION_TIMES);
	Wd = [0; 0; 0];
	W_dot_d = [0; 0; 0];

	%%%%%%%%%%%%%%%%%%%%%
	%   path planning   %
	%%%%%%%%%%%%%%%%%%%%%
	% cirular motion
	radius = 3;        %[m]
	circum_rate = 0.25; %[hz], times of finished a circular trajectory per second
	yaw_rate = 0.05;    %[hz], times of full rotation around z axis per second
	for i = 1: ITERATION_TIMES
		%plan heading
		if i == 1
			yaw_d(1) = 0;
		else
			yaw_d(i) = yaw_d(i - 1) + (yaw_rate * uav_dynamics.dt * 2 * pi);
		end
		if yaw_d(i) > pi %bound yaw angle between +-180 degree
			yaw_d(i) = yaw_d(i) - (2 * pi);
		end

		%plan position
		xd(1, i) = radius * cos(circum_rate * uav_dynamics.dt * i * pi);
		xd(2, i) = radius * sin(circum_rate * uav_dynamics.dt * i * pi);
		xd(3, i) = -1;

		%plan velocity
		vd(1, i) = radius * -sin(circum_rate * uav_dynamics.dt * i * pi);
		vd(2, i) = radius * cos(circum_rate * uav_dynamics.dt * i * pi);
		vd(3, i) = 0;
	end

	%plot datas
	time_arr = zeros(1, ITERATION_TIMES);
	accel_arr = zeros(3, ITERATION_TIMES);
	vel_arr.g = zeros(3, ITERATION_TIMES);
	R_arr = zeros(3, 3, ITERATION_TIMES);
	euler_arr = zeros(3, ITERATION_TIMES);
	pos_arr = zeros(3, ITERATION_TIMES);
	W_dot_arr = zeros(3, ITERATION_TIMES);
	W_arr = zeros(3, ITERATION_TIMES);
	M_arr = zeros(3, ITERATION_TIMES);
	prv_angle_arr = zeros(1, ITERATION_TIMES);
	eR_prv_arr = zeros(3, ITERATION_TIMES);
	eR_arr = zeros(3, ITERATION_TIMES);
	eW_arr = zeros(3, ITERATION_TIMES);
	ex_arr = zeros(3, ITERATION_TIMES);
	ev_arr = zeros(3, ITERATION_TIMES);

	for i = 1: ITERATION_TIMES
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Update System Dynamics %
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		uav_dynamics = update(uav_dynamics);
        q = math.dcm_to_quaternion(uav_dynamics.R); %DCM to quaternion

		%%%%%%%%%%%%%%%%%%%%%%%%%
		% Quadrotor LQR Control %
		%%%%%%%%%%%%%%%%%%%%%%%%%
        
		%construct system state vecoctor
        x = [uav_dynamics.x; q; uav_dynamics.v];

        %construct A matrix
        dpdot_dv = eye(3);
        
        q_norm = norm(q);
        v= (q_norm^-1) * ([1; 1; 1; 1] - (q_norm^-2)*q* transpose(q));
        
        wx = uav_dynamics.W(1);
        wy = uav_dynamics.W(2);
        wz = uav_dynamics.W(3);
        W = [0  -wx -wy -wz;
             wx  0   wz -wy;
             wy -wz   0  wx;
             wz  wy -wx  0];
        dqdot_dq = 0.5 * W * v;
        
        qw = q(1);
        qx = q(2);
        qy = q(3);
        qz = q(4);
        
        c= 1; %FIXME
        Q = [ qy  qz  qw qx;
             -qx -qw  qz qy;
              qw -qx -qy qz];
        dvdot_dq = 2 * c * Q * v;
        
        A = [zeros(3, 3) zeros(3 ,4) dpdot_dv;
             zeros(4, 3) dqdot_dq    zeros(4, 3);
             zeros(3, 3) dvdot_dq    zeros(3, 3)];
        
        %construct B matrix
        dqdot_dw = 0.5 * [-qx -qy -qz;
                           qw -qz -qy;
                           qz  qw  qx;
                          -qy  qx  qw];
        
        dvdot_dc = [qw*qy + qx*qz;
                    qy*qz - qw*qx;
                    qw^2 - qx^2 - qy^2 + qz^2];
        
        B = [zeros(3, 3)  zeros(3, 1);
                dqdot_dw  zeros(4, 1);
             zeros(3, 3)  dvdot_dc];
        
        %construct desired state vector
        p_d = [0; 0; 0];    %desired position
        q_d = [1; 0; 0; 0]; %desired attitude quaternion
        v_d = [0; 0; 0];    %desired velocity
        x_d = [p_d; q_d; v_d];
         
        %lqr control
        %C = eye(10); %measurement matrix is identical, every states are measurable
        %H = transpose(C) * Q * C;
        %[X, L, G] = care(A, B, H, R);
        %K_lqr = inv(R) * transpose(B) * X;
        %u = -K_lqr*(x-x_d);
        
        %full state feedback control
        u = -K_full_state_fb*(x-x_d);

        uav_ctrl_M = [u(1); u(2); u(3)];
        uav_ctrl_f = c * uav_dynamics.R * [0; 0; 1];

		%feed
		uav_dynamics.M = 0; %uav_ctrl_M;
		uav_dynamics.f = 0; %uav_ctrl_f;
        
		%attitude errors expressed in principle rotation angle
		eR_prv = 0; %0.5 * trace(I - Rdt*uav_dynamics.R);
        
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Record datas for plotting %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		time_arr(i) = i * uav_dynamics.dt;
		time_arr(i) = i * uav_dynamics.dt;
		eR_prv_arr(:, i) = rad2deg(eR_prv);
		eR_arr(:, i) = 0; %rad2deg(eR);
		eW_arr(:, i) = 0; %rad2deg(eW);
		accel_arr(:, i) = uav_dynamics.a;
		vel_arr.g(:, i) = uav_dynamics.v;
		pos_arr(:, i) = uav_dynamics.x;
		R_arr(:, :, i) = uav_dynamics.R;
		euler_arr(:, i) = rad2deg(math.dcm_to_euler(uav_dynamics.R));
		W_dot_arr(:, i) = rad2deg(uav_dynamics.W_dot);
		W_arr(:, i) = rad2deg(uav_dynamics.W);
		M_arr(:, i) = uav_dynamics.M;
		ex_arr(:, i) = 0; %ex;
		ev_arr(:, i) = 0; %ev;
	end

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Animate the simulation result %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%rigidbody_visualize([7; 7; 7], pos_arr, R_arr, ITERATION_TIMES, uav_dynamics.dt, 30);

	%%%%%%%%%%%%%%%%%%%%%%%%%%
	%          Plot          %
	%%%%%%%%%%%%%%%%%%%%%%%%%%

	%principle rotation error angle
	figure('Name', 'principle rotation error angle');
	plot(time_arr, eR_prv_arr(1, :));
	title('principle rotation error angle');
	xlabel('time [s]');
	ylabel('x [deg]');

	%attitude error  
	figure('Name', 'eR');
	subplot (3, 1, 1);
	plot(time_arr, eR_arr(1, :));
	title('eR');
	xlabel('time [s]');
	ylabel('x [deg]');
	subplot (3, 1, 2);
	plot(time_arr, eR_arr(2, :));
	xlabel('time [s]');
	ylabel('y [deg]');
	subplot (3, 1, 3);
	plot(time_arr, eR_arr(3, :));
	xlabel('time [s]');
	ylabel('z [deg]');

	%attitude rate error
	figure('Name', 'eW');
	subplot (3, 1, 1);
	plot(time_arr, eW_arr(1, :));
	title('eW');
	xlabel('time [s]');
	ylabel('x [deg/s]');
	subplot (3, 1, 2);
	plot(time_arr, eW_arr(2, :));
	xlabel('time [s]');
	ylabel('y [deg/s]');
	subplot (3, 1, 3);
	plot(time_arr, eW_arr(3, :));
	xlabel('time [s]');
	ylabel('z [deg/s]');

	%attitude (euler angles)
	figure('Name', 'attitude (euler angles)');
	subplot (3, 1, 1);
	plot(time_arr, euler_arr(1, :));
	title('attitude (euler angles)');
	xlabel('time [s]');
	ylabel('roll [deg]');
	subplot (3, 1, 2);
	plot(time_arr, euler_arr(2, :));
	xlabel('time [s]');
	ylabel('pitch [deg]');
	subplot (3, 1, 3);
	plot(time_arr, euler_arr(3, :), time_arr, rad2deg(yaw_d));
	xlabel('time [s]');
	ylabel('yaw [deg]');

	%position
	figure('Name', 'position (NED frame)');
	subplot (3, 1, 1);
	plot(time_arr, pos_arr(1, :), time_arr, xd(1, :));
	title('position (NED frame)');
	xlabel('time [s]');
	ylabel('x [m]');
	subplot (3, 1, 2);
	plot(time_arr, pos_arr(2, :), time_arr, xd(2, :));
	xlabel('time [s]');
	ylabel('y [m]');
	subplot (3, 1, 3);
	plot(time_arr, -pos_arr(3, :), time_arr, -xd(3, :));
	xlabel('time [s]');
	ylabel('-z [m]');

	%velocity
	figure('Name', 'velocity (NED frame)');
	subplot (3, 1, 1);
	plot(time_arr, vel_arr.g(1, :), time_arr, vd(1, :));
	title('velocity (NED frame)');
	xlabel('time [s]');
	ylabel('x [m/s]');
	subplot (3, 1, 2);
	plot(time_arr, vel_arr.g(2, :), time_arr, vd(2, :));
	xlabel('time [s]');
	ylabel('y [m/s]');
	subplot (3, 1, 3);
	plot(time_arr, -vel_arr.g(3, :), time_arr, -vd(3, :));
	xlabel('time [s]');
	ylabel('-z [m/s]');

	%acceleration
	figure('Name', 'acceleration (NED frame)');
	subplot (3, 1, 1);
	plot(time_arr, accel_arr(1, :));
	title('acceleration (NED frame)');
	xlabel('time [s]');
	ylabel('x [m/s^2]');
	subplot (3, 1, 2);
	plot(time_arr, accel_arr(2, :));
	xlabel('time [s]');
	ylabel('y [m/s^2]');
	subplot (3, 1, 3);
	plot(time_arr, -accel_arr(3, :));
	xlabel('time [s]');
	ylabel('-z [m/s^2]');

	%position error
	figure('Name', 'position error');
	subplot (3, 1, 1);
	plot(time_arr, ex_arr(1, :));
	title('position error');
	xlabel('time [s]');
	ylabel('x [m]');
	subplot (3, 1, 2);
	plot(time_arr, ex_arr(2, :));
	xlabel('time [s]');
	ylabel('y [m]');
	subplot (3, 1, 3);
	plot(time_arr, ex_arr(3, :));
	xlabel('time [s]');
	ylabel('z [m]');

	%velocity error
	figure('Name', 'velocity error');
	subplot (3, 1, 1);
	plot(time_arr, ev_arr(1, :));
	title('velocity error');
	xlabel('time [s]');
	ylabel('x [m/s]');
	subplot (3, 1, 2);
	plot(time_arr, ev_arr(2, :));
	xlabel('time [s]');
	ylabel('y [m/s]');
	subplot (3, 1, 3);
	plot(time_arr, ev_arr(3, :));
	xlabel('time [s]');
	ylabel('z [m/s]');

	disp("Press any key to leave");
	pause;
end

function quad_sim_greeting(dynamics, iteration_times, init_attitude)
	roll = rad2deg(init_attitude(1));
	pitch = rad2deg(init_attitude(2));
	yaw = rad2deg(init_attitude(3));
	disp(sprintf('Quadrotor simulation (%d iterations, dt = %dsec)', iteration_times, dynamics.dt));
	disp(sprintf('Initial position: (%f, %f, %f)', dynamics.x(1), dynamics.x(2), dynamics.x(3)));
	disp(sprintf('Initial attitude (euler angle): (%f, %f, %f)', roll, pitch, yaw));
	disp('Start simulation...');
end
