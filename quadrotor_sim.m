function quadrotor_sim
	ITERATION_TIMES = 20000;

	math = se3_math;

	uav_dynamics = dynamics;        %create uav dynamics object
	uav_dynamics.dt = 0.001;        %set iteration period [sec]
	uav_dynamics.mass = 1;          %set uav mass [kg]
	uav_dynamics.a = [0; 0; 0];     %acceleration of uav [m/s^2], effected by applied force
	uav_dynamics.v = [0; 0; 0];     %initial velocity of uav [m/s]
	uav_dynamics.x = [3; 0; -7];    %initial position of uav [m]
	uav_dynamics.W = [0; 0; 0];     %initial angular velocity of uav
	uav_dynamics.W_dot = [0; 0; 0]; %angular acceleration of uav, effected by applied moment
	uav_dynamics.f = [0; 0; 0];     %force generated by controller
	uav_dynamics.M = [0; 0; 0];     %moment generated by controller

	%set initial attitude (DCM)
	init_attitude(1) = deg2rad(180); %roll
	init_attitude(2) = deg2rad(0);   %pitch
	init_attitude(3) = deg2rad(0);   %yaw
	uav_dynamics.R = math.euler_to_dcm(init_attitude(1), init_attitude(2), init_attitude(3));

	uav_dynamics.J = [0.01466 0 0;  %inertia matrix of uav
			  0 0.01466 0;
			  0 0 0.02848];

	quad_sim_greeting(uav_dynamics, ITERATION_TIMES, init_attitude);

	%controller gains
	kx = [7.0; 7.0; 7.0];
	kv = [3.0; 3.0; 3.0];
	kR = [10; 10; 10];
	kW = [2; 2; 2];

	%controller setpoints	
	xd = zeros(3, ITERATION_TIMES);
	vd = zeros(3, ITERATION_TIMES);
	a_d = [0; 0; 0];
	yaw_d = zeros(1, ITERATION_TIMES);
	Wd = [0; 0; 0];
	W_dot_d = [0; 0; 0];

	%%%%%%%%%%%%%%%%%%%%%
	%   path planning   %
	%%%%%%%%%%%%%%%%%%%%%
	% cirular motion
	radius = 3;        %[m]
	circum_rate = 0.25; %[hz], times of finished a circular trajectory per second
	yaw_rate = 0.05;    %[hz], times of full rotation around z axis per second
	for i = 1: ITERATION_TIMES
		%plan heading
		if i == 1
			yaw_d(1) = 0;
		else
			yaw_d(i) = yaw_d(i - 1) + (yaw_rate * uav_dynamics.dt * 2 * pi);
		end
		if yaw_d(i) > pi %bound yaw angle between +-180 degree
			yaw_d(i) = yaw_d(i) - (2 * pi);
		end

		%plan position
		xd(1, i) = radius * cos(circum_rate * uav_dynamics.dt * i * pi);
		xd(2, i) = radius * sin(circum_rate * uav_dynamics.dt * i * pi);
		xd(3, i) = -1;

		%plan velocity
		vd(1, i) = radius * -sin(circum_rate * uav_dynamics.dt * i * pi);
		vd(2, i) = radius * cos(circum_rate * uav_dynamics.dt * i * pi);
		vd(3, i) = 0;
	end

	%plot datas
	time_arr = zeros(1, ITERATION_TIMES);
	accel_arr = zeros(3, ITERATION_TIMES);
	vel_arr.g = zeros(3, ITERATION_TIMES);
	R_arr = zeros(3, 3, ITERATION_TIMES);
	euler_arr = zeros(3, ITERATION_TIMES);
	pos_arr = zeros(3, ITERATION_TIMES);
	W_dot_arr = zeros(3, ITERATION_TIMES);
	W_arr = zeros(3, ITERATION_TIMES);
	M_arr = zeros(3, ITERATION_TIMES);
	prv_angle_arr = zeros(1, ITERATION_TIMES);
	eR_prv_arr = zeros(3, ITERATION_TIMES);
	eR_arr = zeros(3, ITERATION_TIMES);
	eW_arr = zeros(3, ITERATION_TIMES);
	ex_arr = zeros(3, ITERATION_TIMES);
	ev_arr = zeros(3, ITERATION_TIMES);

	for i = 1: ITERATION_TIMES
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Update System Dynamics %
		%%%%%%%%%%%%%%%%%%%%%%%%%%
		uav_dynamics = update(uav_dynamics);

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Geometry Tracking Controller for Quadrotor %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		%tracking erros
		ex(1) = uav_dynamics.x(1) - xd(1, i);
		ex(2) = uav_dynamics.x(2) - xd(2, i);
		ex(3) = uav_dynamics.x(3) - xd(3, i);
		ev(1) = uav_dynamics.v(1) - vd(1, i);
		ev(2) = uav_dynamics.v(2) - vd(2, i);
		ev(3) = uav_dynamics.v(3) - vd(3, i);

		%calculate thrust for quadrotor
		e3 = [0; 0; 1];
		%calculate the thrust vector on inertial frame [e1; e2; e3]
		f_n = [0; 0; 0];
		f_n(1) = -(-kx(1)*ex(1) - kv(1)*ev(1) - uav_dynamics.mass*uav_dynamics.g*e3(1) + uav_dynamics.mass*a_d(1));
		f_n(2) = -(-kx(2)*ex(2) - kv(2)*ev(2) - uav_dynamics.mass*uav_dynamics.g*e3(2) + uav_dynamics.mass*a_d(2));
		f_n(3) = -(-kx(3)*ex(3) - kv(3)*ev(3) - uav_dynamics.mass*uav_dynamics.g*e3(3) + uav_dynamics.mass*a_d(3));

		%calculate desired dcm
		b1d = [cos(yaw_d(i)); sin(yaw_d(i)); 0];
		b3d = [0; 0; 0];
		b3d(1) = f_n(1) / norm(f_n);
		b3d(2) = f_n(2) / norm(f_n);
		b3d(3) = f_n(3) / norm(f_n);
		b2d = cross(b3d, b1d);
		b1d_proj = cross(b2d, b3d);
		Rd = [b1d_proj b2d b3d];
		%disp(Rd);
		%disp(det(Rd))

		f_total = dot(f_n, Rd * e3); %quadrotor total thrust on body frame
		
		%attitude manual control input
		%desired_roll = deg2rad(30);
		%desired_pitch = deg2rad(10);
		%desired_yaw = deg2rad(35);
		%Rd = math.euler_to_dcm(desired_roll, desired_pitch, desired_yaw);

		Rt = uav_dynamics.R';
		Rdt = Rd';
		I = eye(3);

		%attitude errors expressed in principle rotation angle
		eR_prv = 0.5 * trace(I - Rdt*uav_dynamics.R);

		%attitude errors
		eR = 0.5 * math.vee_map_3x3((Rd'*uav_dynamics.R - Rt*Rd));
		eW = uav_dynamics.W - Rt*Rd*Wd;

		%control output: moment
		WJW = cross(uav_dynamics.W, uav_dynamics.J * uav_dynamics.W);
		M_feedfoward = WJW - uav_dynamics.J*(math.hat_map_3x3(uav_dynamics.W)*Rt*Rd*Wd - Rt*Rd*W_dot_d);

		uav_ctrl_M = [-kR(1)*eR(1) - kW(1)*eW(1) + M_feedfoward(1);
			      -kR(2)*eR(2) - kW(2)*eW(2) + M_feedfoward(2);
			      -kR(3)*eR(3) - kW(3)*eW(3) + M_feedfoward(3)];

		%control output: force
		uav_ctrl_f = f_total * uav_dynamics.R * e3;

		%feed control to quadrotor's model and convert it to generalized rigidbody dynamics
		M_n = [0; 0; 0]; %this is the quantity we want to feed to the rigidbody dynamics
		f_n = [0; 0; 0]; %this is the quantity we want to feed to the rigidbody dynamics
		motor_thrusts = [0; 0; 0; 0]; %thrust value of quadrotor's 4 motors
		quadrotor.d = 0.45;           %[m], distance of quadrotor's center to motor location
		quadrotor.c_tau = 0.009012;   %[N*m/(rad/s)^2]
		motor_thrusts = quadrotor_thrust_allocation(quadrotor, uav_ctrl_M, f_total);
		[M_n, f_n] = quadrotor_thrust_to_rigidbody_dynamics(quadrotor, motor_thrusts, uav_dynamics.R);

		%feed
		uav_dynamics.M = uav_ctrl_M;
		uav_dynamics.f = uav_ctrl_f;

		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		% Record datas for plotting %
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		time_arr(i) = i * uav_dynamics.dt;
		time_arr(i) = i * uav_dynamics.dt;
		eR_prv_arr(:, i) = rad2deg(eR_prv);
		eR_arr(:, i) = rad2deg(eR);
		eW_arr(:, i) = rad2deg(eW);
		accel_arr(:, i) = uav_dynamics.a;
		vel_arr.g(:, i) = uav_dynamics.v;
		pos_arr(:, i) = uav_dynamics.x;
		R_arr(:, :, i) = uav_dynamics.R;
		euler_arr(:, i) = rad2deg(math.dcm_to_euler(uav_dynamics.R));
		W_dot_arr(:, i) = rad2deg(uav_dynamics.W_dot);
		W_arr(:, i) = rad2deg(uav_dynamics.W);
		M_arr(:, i) = uav_dynamics.M;
		ex_arr(:, i) = ex;
		ev_arr(:, i) = ev;
	end

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Animate the simulation result %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	rigidbody_visualize([7; 7; 7], pos_arr, R_arr, ITERATION_TIMES, uav_dynamics.dt, 30);

	%%%%%%%%%%%%%%%%%%%%%%%%%%
	%          Plot          %
	%%%%%%%%%%%%%%%%%%%%%%%%%%

	%principle rotation error angle
	figure('Name', 'principle rotation error angle');
	plot(time_arr, eR_prv_arr(1, :));
	title('principle rotation error angle');
	xlabel('time [s]');
	ylabel('x [deg]');

	%attitude error  
	figure('Name', 'eR');
	subplot (3, 1, 1);
	plot(time_arr, eR_arr(1, :));
	title('eR');
	xlabel('time [s]');
	ylabel('x [deg]');
	subplot (3, 1, 2);
	plot(time_arr, eR_arr(2, :));
	xlabel('time [s]');
	ylabel('y [deg]');
	subplot (3, 1, 3);
	plot(time_arr, eR_arr(3, :));
	xlabel('time [s]');
	ylabel('z [deg]');

	%attitude rate error
	figure('Name', 'eW');
	subplot (3, 1, 1);
	plot(time_arr, eW_arr(1, :));
	title('eW');
	xlabel('time [s]');
	ylabel('x [deg/s]');
	subplot (3, 1, 2);
	plot(time_arr, eW_arr(2, :));
	xlabel('time [s]');
	ylabel('y [deg/s]');
	subplot (3, 1, 3);
	plot(time_arr, eW_arr(3, :));
	xlabel('time [s]');
	ylabel('z [deg/s]');

	%attitude (euler angles)
	figure('Name', 'attitude (euler angles)');
	subplot (3, 1, 1);
	plot(time_arr, euler_arr(1, :));
	title('attitude (euler angles)');
	xlabel('time [s]');
	ylabel('roll [deg]');
	subplot (3, 1, 2);
	plot(time_arr, euler_arr(2, :));
	xlabel('time [s]');
	ylabel('pitch [deg]');
	subplot (3, 1, 3);
	plot(time_arr, euler_arr(3, :), time_arr, rad2deg(yaw_d));
	xlabel('time [s]');
	ylabel('yaw [deg]');

	%position
	figure('Name', 'position (NED frame)');
	subplot (3, 1, 1);
	plot(time_arr, pos_arr(1, :), time_arr, xd(1, :));
	title('position (NED frame)');
	xlabel('time [s]');
	ylabel('x [m]');
	subplot (3, 1, 2);
	plot(time_arr, pos_arr(2, :), time_arr, xd(2, :));
	xlabel('time [s]');
	ylabel('y [m]');
	subplot (3, 1, 3);
	plot(time_arr, -pos_arr(3, :), time_arr, -xd(3, :));
	xlabel('time [s]');
	ylabel('-z [m]');

	%velocity
	figure('Name', 'velocity (NED frame)');
	subplot (3, 1, 1);
	plot(time_arr, vel_arr.g(1, :), time_arr, vd(1, :));
	title('velocity (NED frame)');
	xlabel('time [s]');
	ylabel('x [m/s]');
	subplot (3, 1, 2);
	plot(time_arr, vel_arr.g(2, :), time_arr, vd(2, :));
	xlabel('time [s]');
	ylabel('y [m/s]');
	subplot (3, 1, 3);
	plot(time_arr, -vel_arr.g(3, :), time_arr, -vd(3, :));
	xlabel('time [s]');
	ylabel('-z [m/s]');

	%acceleration
	figure('Name', 'acceleration (NED frame)');
	subplot (3, 1, 1);
	plot(time_arr, accel_arr(1, :));
	title('acceleration (NED frame)');
	xlabel('time [s]');
	ylabel('x [m/s^2]');
	subplot (3, 1, 2);
	plot(time_arr, accel_arr(2, :));
	xlabel('time [s]');
	ylabel('y [m/s^2]');
	subplot (3, 1, 3);
	plot(time_arr, -accel_arr(3, :));
	xlabel('time [s]');
	ylabel('-z [m/s^2]');

	%position error
	figure('Name', 'position error');
	subplot (3, 1, 1);
	plot(time_arr, ex_arr(1, :));
	title('position error');
	xlabel('time [s]');
	ylabel('x [m]');
	subplot (3, 1, 2);
	plot(time_arr, ex_arr(2, :));
	xlabel('time [s]');
	ylabel('y [m]');
	subplot (3, 1, 3);
	plot(time_arr, ex_arr(3, :));
	xlabel('time [s]');
	ylabel('z [m]');

	%velocity error
	figure('Name', 'velocity error');
	subplot (3, 1, 1);
	plot(time_arr, ev_arr(1, :));
	title('velocity error');
	xlabel('time [s]');
	ylabel('x [m/s]');
	subplot (3, 1, 2);
	plot(time_arr, ev_arr(2, :));
	xlabel('time [s]');
	ylabel('y [m/s]');
	subplot (3, 1, 3);
	plot(time_arr, ev_arr(3, :));
	xlabel('time [s]');
	ylabel('z [m/s]');

	disp("Press any key to leave");
	pause;
end

function motor_thrusts = quadrotor_thrust_allocation(quad, M, f)
	allocation_inv = [0.25, -0.25*quad.d, +0.25*quad.d, -0.25*quad.c_tau;
			  0.25, +0.25*quad.d, +0.25*quad.d, +0.25*quad.c_tau;
			  0.25, +0.25*quad.d, -0.25*quad.d, -0.25*quad.c_tau;
			  0.25, -0.25*quad.d, -0.25*quad.d, +0.25*quad.c_tau];
	motor_thrusts = [0; 0; 0; 0];
	motor_thrusts = allocation_inv * [f; M(1); M(2); M(3)];
end

function [M, f_3d] = quadrotor_thrust_to_rigidbody_dynamics(quad, f_motors, R)
	cg_position = [0; 0; 0];

	cg_to_m1 = [cos(deg2rad(45));  sin(deg2rad(45));  0];   %motor1's position
	cg_to_m2 = [cos(deg2rad(135)); sin(deg2rad(135)); 0]; %motor2's position
	cg_to_m3 = [cos(deg2rad(225)); sin(deg2rad(225)); 0]; %motor3's position
	cg_to_m4 = [cos(deg2rad(315)); sin(deg2rad(315)); 0]; %motor4's position

	%calculate the moment generated by each motors wrt to the center of gravity
	M_m1 = cross(cg_to_m1, [0; 0; -f_motors(1)]);
	M_m2 = cross(cg_to_m2, [0; 0; -f_motors(2)]);
	M_m3 = cross(cg_to_m3, [0; 0; -f_motors(3)]);
	M_m4 = cross(cg_to_m4, [0; 0; -f_motors(4)]);

	%composite moment of all motors and transform it to the inertial frame
	M = [0; 0; 0];
	M = R * (M_m1 + M_m2 + M_m3 + M_m4);
	%composite force of all motors and transform it to the inertial frame
	f_3d = R * (f_motors(1) + f_motors(2) + f_motors(3) + f_motors(4));
end

function quad_sim_greeting(dynamics, iteration_times, init_attitude)
	roll = rad2deg(init_attitude(1));
	pitch = rad2deg(init_attitude(2));
	yaw = rad2deg(init_attitude(3));
	disp(sprintf('Quadrotor simulation (%d iterations, dt = %dsec)', iteration_times, dynamics.dt));
	disp(sprintf('Initial position: (%f, %f, %f)', dynamics.x(1), dynamics.x(2), dynamics.x(3)));
	disp(sprintf('Initial attitude (euler angle): (%f, %f, %f)', roll, pitch, yaw));
	disp('Start simulation...');
end
